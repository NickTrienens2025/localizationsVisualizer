#!/usr/bin/env python3
"""
Swift Localization Migration Script (Python Version)
Generated on: {{ timestamp }}
Total keys to migrate: {{ key_mapping|length }}

This script finds and replaces old localization patterns in Swift files
and updates localization files with migration comments.
"""

import os
import re
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from datetime import datetime


@dataclass
class MigrationResult:
    """Result of a migration operation"""
    file_path: str
    line_number: int
    original_line: str
    replacement: str
    key: str
    has_parameters: bool
    found_replacement: bool


class LocalizationMigrator:
    def __init__(self, project_dir: str, key_mapping: Dict[str, Dict]):
        self.project_dir = Path(project_dir)
        self.key_mapping = key_mapping
        self.replacement_counts = {}
        self.migration_results = []
        
    def find_localization_file(self) -> Optional[Path]:
        """Find the localization file in the project directory"""
        possible_paths = [
            self.project_dir / "en.proj" / "Localizable.strings",
            self.project_dir / "Resources" / "en.lproj" / "Localizable.strings",
            self.project_dir / "Resources" / "en.lproj" / "Localizable.strings",
            self.project_dir / "nhl-ios" / "Resources" / "en.lproj" / "Localizable.strings"
        ]
        
        for path in possible_paths:
            if path.exists():
                return path
        return None
    
    def scan_swift_files(self) -> List[Path]:
        """Find all Swift files in the project directory"""
        swift_files = []
        for root, dirs, files in os.walk(self.project_dir):
            # Skip common directories that shouldn't contain Swift files
            dirs[:] = [d for d in dirs if d not in ['.git', 'build', 'DerivedData', 'Pods', 'Carthage']]
            
            for file in files:
                if file.endswith('.swift'):
                    swift_files.append(Path(root) / file)
        return swift_files
    
    def extract_localization_key(self, line: str) -> Optional[str]:
        """Extract localization key from a Swift line"""
        # Pattern for String(localized: "key")
        pattern1 = r'String\(localized:\s*"([^"]+)"'
        match = re.search(pattern1, line)
        if match:
            return match.group(1)
        
        # Pattern for String(formattedLocalization: "key")
        pattern2 = r'String\(formattedLocalization:\s*"([^"]+)"'
        match = re.search(pattern2, line)
        if match:
            return match.group(1)
        
        return None
    
    def is_compound_localization(self, lines: List[str], start_line: int) -> bool:
        """Check if this is a compound localization using String.localizedStringWithFormat"""
        if start_line >= len(lines):
            return False
        
        line = lines[start_line - 1]  # Convert to 0-based index
        return 'String.localizedStringWithFormat(' in line
    
    def extract_compound_localization(self, lines: List[str], start_line: int) -> Optional[Tuple[str, List[str], int]]:
        """Extract compound localization pattern and return (key, parameters, end_line)"""
        if start_line > len(lines):
            return None
        
        line_idx = start_line - 1  # Convert to 0-based index
        line = lines[line_idx]
        
        # Check if this is a compound localization
        if 'String.localizedStringWithFormat(' not in line:
            return None
        
        # Extract the localization key
        key_match = re.search(r'String\(localized:\s*"([^"]+)"', line)
        if not key_match:
            return None
        
        key = key_match.group(1)
        
        # Find the end of the String.localizedStringWithFormat call
        open_parens = line.count('(') - line.count(')')
        parameters = []
        end_line = start_line
        
        # Continue reading lines until we find the closing parenthesis
        current_line_idx = line_idx
        while open_parens > 0 and current_line_idx < len(lines) - 1:
            current_line_idx += 1
            current_line = lines[current_line_idx]
            end_line += 1
            
            open_parens += current_line.count('(') - current_line.count(')')
            
            # Extract parameters (everything between the first comma and the closing parenthesis)
            if current_line_idx == line_idx + 1:  # First continuation line
                # Remove the String(localized: "key"), part and extract parameters
                param_start = current_line.find(',') + 1
                if param_start > 0:
                    param_content = current_line[param_start:].strip()
                    if param_content:
                        parameters.append(param_content)
            else:
                # Subsequent lines are all parameters
                param_content = current_line.strip()
                if param_content:
                    parameters.append(param_content)
        
        return (key, parameters, end_line)
    
    def process_swift_file(self, file_path: Path, skip_complex: bool = False) -> List[MigrationResult]:
        """Process a single Swift file and find localization patterns"""
        results = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            line_num = 1
            while line_num <= len(lines):
                line = lines[line_num - 1]
                
                # Check for compound localization first
                if self.is_compound_localization(lines, line_num):
                    compound_result = self.extract_compound_localization(lines, line_num)
                    if compound_result:
                        key, parameters, end_line = compound_result
                    #     result = self.process_compound_localization(file_path, line_num, end_line, lines, key, parameters)
                    #     if result:
                    #         results.append(result)
                        line_num = end_line + 1  # Skip to after the compound localization
                        continue
                
                # Check for simple localization
                key = self.extract_localization_key(line)
                if key:
                    result = self.process_localization_line(file_path, line_num, line, key, skip_complex)
                    if result:
                        results.append(result)
                
                line_num += 1
                        
        except Exception as e:
            print(f"Error processing {file_path}: {e}")
        
        return results
    
    def process_localization_line(self, file_path: Path, line_num: int, line: str, key: str, skip_complex: bool = False) -> Optional[MigrationResult]:
        """Process a single localization line"""
        if key in self.key_mapping:
            mapping_info = self.key_mapping[key]
            enum_path = mapping_info['enum_path']
            has_parameters = mapping_info['has_parameters']
            
            # Skip complex localizations if requested
            if skip_complex and has_parameters:
                return MigrationResult(
                    file_path=str(file_path),
                    line_number=line_num,
                    original_line=line.rstrip(),
                    replacement="",
                    key=key,
                    has_parameters=has_parameters,
                    found_replacement=False
                )
            
            # Create replacement
            replacement = f"DependencyContainer.localizations.string(for: {enum_path})"
            
            # Update replacement count
            self.replacement_counts[key] = self.replacement_counts.get(key, 0) + 1
            
            return MigrationResult(
                file_path=str(file_path),
                line_number=line_num,
                original_line=line.rstrip(),
                replacement=replacement,
                key=key,
                has_parameters=has_parameters,
                found_replacement=True
            )
        else:
            return MigrationResult(
                file_path=str(file_path),
                line_number=line_num,
                original_line=line.rstrip(),
                replacement="",
                key=key,
                has_parameters=False,
                found_replacement=False
            )
    
    def process_compound_localization(self, file_path: Path, start_line: int, end_line: int, lines: List[str], key: str, parameters: List[str]) -> Optional[MigrationResult]:
        """Process a compound localization using String.localizedStringWithFormat"""
        if key in self.key_mapping:
            mapping_info = self.key_mapping[key]
            enum_path = mapping_info['enum_path']
            has_parameters = mapping_info['has_parameters']
            
            # Create the original multi-line text
            original_lines = lines[start_line - 1:end_line]
            original_text = ''.join(original_lines).rstrip()
            
            # Create replacement with parameters
            if has_parameters and parameters:
                # Format parameters for the enum call
                param_strings = []
                for param in parameters:
                    param_clean = param.strip().rstrip(',')
                    if param_clean:
                        param_strings.append(param_clean)
                
                param_args = ', '.join(param_strings)
                replacement = f"DependencyContainer.localizations.string(for: {enum_path}({param_args}))"
            else:
                replacement = f"DependencyContainer.localizations.string(for: {enum_path})"
            
            # Update replacement count
            self.replacement_counts[key] = self.replacement_counts.get(key, 0) + 1
            
            return MigrationResult(
                file_path=str(file_path),
                line_number=start_line,
                original_line=original_text,
                replacement=replacement,
                key=key,
                has_parameters=has_parameters,
                found_replacement=True
            )
        else:
            return MigrationResult(
                file_path=str(file_path),
                line_number=start_line,
                original_line=''.join(lines[start_line - 1:end_line]).rstrip(),
                replacement="",
                key=key,
                has_parameters=len(parameters) > 0,
                found_replacement=False
            )
    
    def apply_replacements(self, results: List[MigrationResult], dry_run: bool = True) -> None:
        """Apply replacements to Swift files"""
        if dry_run:
            print("\n=== DRY RUN - No changes will be made ===")
        
        # Group results by file
        files_to_update = {}
        for result in results:
            if result.found_replacement:
                if result.file_path not in files_to_update:
                    files_to_update[result.file_path] = []
                files_to_update[result.file_path].append(result)
        
        for file_path, file_results in files_to_update.items():
            if dry_run:
                print(f"\nWould update {file_path}:")
            else:
                print(f"\nUpdating {file_path}:")
            
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                
                # Sort results by line number in descending order to avoid line number shifts
                file_results.sort(key=lambda x: x.line_number, reverse=True)
                
                for result in file_results:
                    line_idx = result.line_number - 1
                    if 0 <= line_idx < len(lines):
                        original_line = lines[line_idx]
                        
                        # Check if this is a compound localization (multi-line)
                        if 'String.localizedStringWithFormat(' in original_line:
                            # This is a compound localization - replace the entire multi-line block
                            # Find the end of the String.localizedStringWithFormat call
                            open_parens = original_line.count('(') - original_line.count(')')
                            end_line_idx = line_idx
                            
                            # Continue reading lines until we find the closing parenthesis
                            current_line_idx = line_idx
                            while open_parens > 0 and current_line_idx < len(lines) - 1:
                                current_line_idx += 1
                                current_line = lines[current_line_idx]
                                end_line_idx = current_line_idx
                                open_parens += current_line.count('(') - current_line.count(')')
                            
                            # Replace the entire multi-line block with the new replacement
                            if dry_run:
                                print(f"Lines {result.line_number}-{end_line_idx + 1}:")
                                print(f"    Original: {''.join(lines[line_idx:end_line_idx + 1]).rstrip()}")
                                print(f"    Replacement: {result.replacement}")
                            else:
                                # Remove the old lines and insert the new replacement
                                del lines[line_idx:end_line_idx + 1]
                                lines.insert(line_idx, result.replacement + '\n')
                                print(f"  Lines {result.line_number}-{end_line_idx + 1}: Updated")
                        
                        # Handle simple String(localized:) cases
                        elif 'String(localized:' in original_line:
                            new_line = re.sub(
                                r'String\(localized:\s*"([^"]+)"\)',
                                result.replacement,
                                original_line
                            )
                            
                            if dry_run:
                                print(f"  Line {result.line_number}:")
                                print(f"    Original: {original_line.rstrip()}")
                                print(f"    Replacement: {new_line.rstrip()}")
                            else:
                                lines[line_idx] = new_line
                                print(f"  Line {result.line_number}: Updated")
                        
                        # elif 'String(formattedLocalization:' in original_line:
                        #     new_line = re.sub(
                        #         r'String\(formattedLocalization:\s*"([^"]+)"',
                        #         result.replacement,
                        #         original_line
                        #     )
                        # else:
                        #     new_line = original_line
                
                if not dry_run:
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.writelines(lines)
                        
            except Exception as e:
                print(f"Error updating {file_path}: {e}")
    
    def update_localization_comments(self, dry_run: bool = True) -> None:
        """Update localization file with migration comments"""
        localization_file = self.find_localization_file()
        if not localization_file:
            print("\n⚠️  Localization file not found. Please update manually.")
            return
        
        if dry_run:
            print(f"\nWould update localization file: {localization_file}")
        else:
            print(f"\nUpdating localization file: {localization_file}")
        
        try:
            with open(localization_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            updated_lines = []
            updated_count = 0
            
            for line in lines:
                # Check if this line contains a key that was migrated
                for key, count in self.replacement_counts.items():
                    if line.strip().startswith(f'"{key}"='):
                        # Add migration comment
                        if '//' in line:
                            # Replace existing comment
                            new_line = re.sub(r'//.*$', f'// Migrated - {count} replaced', line)
                        else:
                            # Add new comment
                            new_line = line.rstrip() + f' // Migrated - {count} replaced\n'
                        
                        updated_lines.append(new_line)
                        updated_count += 1
                        break
                else:
                    updated_lines.append(line)
            
            if dry_run:
                print(f"Would update {updated_count} localization entries with migration comments")
            else:
                with open(localization_file, 'w', encoding='utf-8') as f:
                    f.writelines(updated_lines)
                print(f"Updated {updated_count} localization entries with migration comments")
                
        except Exception as e:
            print(f"Error updating localization file: {e}")
    
    def generate_report(self, results: List[MigrationResult]) -> None:
        """Generate a detailed migration report"""
        report_file = "localization_migration_report.txt"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write("# Swift Localization Migration Report\n")
            f.write(f"# Generated on: {datetime.now().isoformat()}\n")
            f.write(f"# Scanned directory: {self.project_dir}\n")
            f.write(f"# Total files processed: {len(set(r.file_path for r in results))}\n")
            f.write(f"# Total localizations found: {len(results)}\n")
            f.write(f"# Total replacements: {len([r for r in results if r.found_replacement])}\n")
            f.write("\n")
            
            # Group results by file
            files_results = {}
            for result in results:
                if result.file_path not in files_results:
                    files_results[result.file_path] = []
                files_results[result.file_path].append(result)
            
            for file_path, file_results in sorted(files_results.items()):
                f.write(f"## File: {file_path}\n\n")
                
                for result in sorted(file_results, key=lambda x: x.line_number):
                    if result.found_replacement:
                        if result.has_parameters:
                            f.write(f"  - Line {result.line_number}: {result.key} [HAS PARAMETERS - MANUAL REVIEW NEEDED]\n")
                            f.write(f"    Original: {result.original_line}\n")
                            f.write(f"    Suggested: {result.replacement}\n")
                            f.write(f"    ⚠️  Manual parameter mapping required\n")
                        else:
                            f.write(f"  - Line {result.line_number}: {result.key}\n")
                            f.write(f"    Original: {result.original_line}\n")
                            f.write(f"    Replacement: {result.replacement}\n")
                    else:
                        f.write(f"  - Line {result.line_number}: {result.key} [UNKNOWN KEY]\n")
                        f.write(f"    Original: {result.original_line}\n")
                        f.write(f"    ⚠️  Key not found in current Contentful data\n")
                    
                    f.write("\n")
                
                f.write("---\n\n")
        
        print(f"\n📄 Migration report saved to: {report_file}")
    
    def run_migration(self, dry_run: bool = True, skip_complex: bool = False) -> None:
        """Run the complete migration process"""
        print(f"🔍 Scanning Swift files in: {self.project_dir}")
        
        swift_files = self.scan_swift_files()
        print(f"Found {len(swift_files)} Swift files")
        
        all_results = []
        for swift_file in swift_files:
            results = self.process_swift_file(swift_file, skip_complex)
            all_results.extend(results)
        
        print(f"\n📊 Migration Summary:")
        print(f"  Total localizations found: {len(all_results)}")
        print(f"  Replacements available: {len([r for r in all_results if r.found_replacement])}")
        print(f"  Unknown keys: {len([r for r in all_results if not r.found_replacement])}")
        if skip_complex:
            print(f"  Complex localizations skipped: {len([r for r in all_results if r.has_parameters and not r.found_replacement])}")
        
        # Generate report
        self.generate_report(all_results)
        
        # Apply replacements
        self.apply_replacements(all_results, dry_run)
        
        # Update localization comments
        self.update_localization_comments(dry_run)
        
        if dry_run:
            print("\n✅ Dry run completed. Review the report and run with --apply to make changes.")
        else:
            print("\n✅ Migration completed successfully!")


def main():
    parser = argparse.ArgumentParser(description='Swift Localization Migration Script')
    parser.add_argument('project_dir', help='Path to Swift project directory')
    parser.add_argument('--apply', action='store_true', help='Apply changes (default is dry run)')
    parser.add_argument('--key-mapping', help='JSON file with key mapping (optional)')
    parser.add_argument('--skip-complex', action='store_true', help='Skip localizations with parameters (complex substitutions)')
    
    args = parser.parse_args()
    
    if not os.path.isdir(args.project_dir):
        print(f"❌ Error: Directory '{args.project_dir}' does not exist")
        sys.exit(1)
    
    # Key mapping (this would normally come from Contentful)
    key_mapping = {
{% for original_key, mapping_info in key_mapping.items() %}
        "{{ original_key }}": {
            "enum_path": "{{ mapping_info.enum_path }}",
            "has_parameters": {{ mapping_info.has_parameters }},
            "parameters": "{{ mapping_info.parameters }}"
        }{% if not loop.last %},{% endif %}
{% endfor %}
    }
    
    print("🚀 Swift Localization Migration Script (Python)")
    print(f"📁 Project directory: {args.project_dir}")
    print(f"🔑 Total keys to migrate: {len(key_mapping)}")
    print(f"🎯 Mode: {'Apply changes' if args.apply else 'Dry run'}")
    if args.skip_complex:
        print(f"⚠️  Complex localizations (with parameters) will be skipped")
    print()
    
    migrator = LocalizationMigrator(args.project_dir, key_mapping)
    migrator.run_migration(dry_run=not args.apply, skip_complex=args.skip_complex)


if __name__ == "__main__":
    main() 